---
title: "操作系统学习笔记 11死锁"
date: 2022-07-31
thumbnailImagePosition: left
thumbnailImage: os/os11_thumb.jpg
coverImage: os/os11_cover.png
metaAlignment: center
coverMeta: out
draft: true
categories:
- OS
- 2022
- July
tags:
- 学习笔记
- 清华大学陈渝
showSocial: false
---
熟悉完操作系统的第十篇章，开始学习第十一篇章，关于操作系统的死锁。

<!--more-->
# 0猜你喜欢

操作系统系列文章

[操作系统学习笔记 1概述](https://yangyang48.github.io/2022/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%E6%A6%82%E8%BF%B0/)

[操作系统学习笔记 2操作系统介绍](https://yangyang48.github.io/2022/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/)

[操作系统学习笔记 3内存管理](https://yangyang48.github.io/2022/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)

[操作系统学习笔记 4非连续内存分配](https://yangyang48.github.io/2022/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/)

[操作系统学习笔记 5虚拟内存](https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/)

[操作系统学习笔记 6页面置换算法](https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/)

[操作系统学习笔记 7进程管理](https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/)

[操作系统学习笔记 8CPU调度](https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8cpu%E8%B0%83%E5%BA%A6/)

[操作系统学习笔记 9同步&互斥](https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/)

[操作系统学习笔记 10信号量&管程](https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%AE%A1%E7%A8%8B/)

[操作系统学习笔记 11死锁](https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11%E6%AD%BB%E9%94%81/)

[操作系统学习笔记 12进程间通信](https://yangyang48.github.io/2022/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/)

[操作系统学习笔记 13文件系统](https://yangyang48.github.io/2022/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/)



# 11死锁

1. 死锁问题

2. 系统模型

3. 死锁特征

4. 死锁处理方法

   Deadlock Prevention（死锁预防）

   Deadlock Avoidance（死锁避免）

   Deadlock Detection（死锁检测）

   Recovery from Deadlock（死锁恢复）



## 11.1死锁问题

{{< image classes="fancybox center fig-100" src="/os/os11_1.png" thumbnail="/os/os11_1.png" title="">}}

- 流量只在一个方向
- 桥的每个部分可以看作为一个资源
- 如果死锁，可以通过一辆车倒退可以解决（抢占资源和回滚）
- 如果发生死锁，可能几辆车必须都倒退
- 可能发生饥饿



- 一组阻塞的进程**持有一种资源**等待获取**另一个进程所占有的一个资源**

- 例子

  系统有2个磁带驱动器

  `P1`和`P2`各有一个，都需要另外一个



## 11.2系统模型

- 资源类型`R1`，`R2`，`R3`，。。。，`Rm`

- CPU cycles，memory space，I/O devices

- 每个资源类型`Ri`有`Wi`实例

- 每个进程使用资源如下

  request/get < -- free resource

  use/hold < -- requested/used resource

  release < -- free resource



**可重复使用的资源**

- 在一个时间只能一个进程使用且不能被删除
- 进程获得资源，后来释放由其他进程重用
- 处理器，I/O通道，主和副存储器，**设备和数据结构**，如文件，数据库和信号量
- 如果每个进程拥有一个资源并请求其他资源，死锁可能发生



**使用资源**

- 创建和销毁
- 在I/O缓存区的中断，信号，消息，信息
- 如果接收消息阻塞可能会发生死锁
- 可能少见的组合事件会引起死锁



资源分配图

一组顶点V和边E的集合

- V有两种类型

  P={`P1`，`P2`，。。。，`Pn`}集合包括系统中的所有进程

  R={`R1`，`R2`，。。。，`Rm`}集合包括系统中的所有资源类型

- requesting/claiming edge - directed edge `Pi` --> `Rj`

- assignment/holding edge - directed edge `Rj` --> `Pi`



{{< image classes="fancybox center fig-100" src="/os/os11_2.png" thumbnail="/os/os11_2.png" title="">}}

资源分配举例说明

可以看到下图11-1中，有`P1`，`P2`，`P3`三个进程，还有资源`R1`，`R2`，`R3`，`R4`四个资源，且`R2`资源有两个类型，`R4`资源有四个类型。这里面的箭头表示进程和资源的关系，`R2`的两种类型的资源分配给`P1`和`P2`，同时`P1`需要`R1`的资源，但是`R1`的资源已经分配给`P2`。同理`R2`同时需要`R3`的资源，但是`R3`的资源已经分配给`P3`。

{{< image classes="fancybox center fig-100" src="/os/os11_3.png" thumbnail="/os/os11_3.png" title="图11-1 资源分配图">}}

上图不存在死锁现象。

这里`P1`和`P2`拿不到`R1`和`R3`的资源。进程使用资源过一段时间会释放资源，进程`P3`运行到一段时间，会释放`R3`的资源，这个时候`P2`就会去申请使用`R3`资源，`P2`就会把资源`R1`，`R2`，`R3`占用，过了一段时间，`P2`释放`R1`资源，进程`P1`这个时候就可以去申请试用`R1`的资源了。



相反，如果图中的箭头形成一个环之后，就会发生死锁现象。

这里有两个环，`P1`-->`R1`-->`P2`-->`R3`-->`P3`-->`R2`-->`P1`和`P2`-->`R3`-->`P3`-->`R2`-->`P2`

在当前进程申请资源的过程中，由于资源被其他进程占用，所以只能等待，其他进程需要的资源又被当前进程占用，也只能等待申请，所以出现死锁现象。

{{< image classes="fancybox center fig-100" src="/os/os11_4.png" thumbnail="/os/os11_4.png" title="">}}



有循环的资源分配还不一定死锁

显然下图11-2所示是有环的，`P1`-->`R1`-->`P3`-->`R2`-->`P1`

这里的`P2`是不需要在申请其他资源，也就是`P2`资源使用完成之后就会释放`R1`资源，而`P1`正在申请`R1`资源，那么`P1`就可以申请试用到`R1`资源，就不会存在死锁的情况

{{< image classes="fancybox center fig-100" src="/os/os11_5.png" thumbnail="/os/os11_5.png" title="图11-2 有循环的资源分配不死锁图">}}



总结

- 如果图中不包含循环，那么就没有死锁
- 如果图中有循环，且每个资源只有一个实例，那么死锁；如果每个资源有多个实例，可能死锁。
- 成环是死锁的必要不充分条件

## 11.3死锁特征

如果四个条件都满足可能出现死锁，如果死锁出现；如果死锁，那么四个条件都满足。

1. **互斥**

   在一个时间只有一个进程使用资源

2. **持有并等待**

   进程保持至少一个资源正在等待获取其他进程所持有的的额外资源

3. **无抢占**

   一个资源只能被进程自愿释放，进程已经完成了它的任务之后

4. **循环等待**

   存在等待进程集合{`P0`，`P1`，。。。，`Pn`}，`P0`正在等待`P1`所占用的资源，`P1`正在等待`P2`所占用的资源，`Pn-1`在等待`Pn`所占用的资源，`Pn`正在等待`P0`所占用的资源。



如下图11-3所示，左边的图满足四个条件，右边的图不满足第二个条件，`P2`和`P4`持有了但并不等待，所以不会死锁。

{{< image classes="fancybox center fig-100" src="/os/os11_6.png" thumbnail="/os/os11_6.png" title="图11-3 没有死锁图">}}



## 11.4死锁处理方法

- 确保系统永远不会进入死锁状态
- 运行系统进入死锁状态，然后恢复
- 忽略这个问题，假装系统中从来没有发生死锁；用于大多数操作系统，包括UNIX



### 11.4.1死锁预防

限制申请方式

- 互斥 - 共享资源不是必须的，必须占用非共享资源

- 占用并等待 - 必须保证当一个进程请求的资源，它不持有任何其他资源

  需要进程请求并分配其所有资源，他开始执行之前或允许进程请求资源仅当进程没有资源

  资源利用率低：可能发生饥饿

- 无抢占

  如果进程占用某些资源，并请求其他不能被立即分配的资源，则释放当前正占有的资源

  被抢占资源添加到资源列表中

  只有当它能够获得旧的资源以及它请求新的资源，进程可以得到执行

- 循环等待 - 对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请



### 11.4.2死锁避免

需要系统具有一些额外的先验信息提供

- 最简单和最有效的模式是要求每个进程声明它可能需要的每个类型的**最大数目**

- 资源的分配状态是通过限定**提供**与**分配**的资源数量，和进程的**最大**需求

- 死锁避免算法**动态检查**的资源分配状态，以确保永远不会有一个环形等待状态

- 当一个进程请求可用资源，系统必须判断立即分配是否能使系统处于安全状态

- 系统处于安全状态：针对所有进程，存在安全序列

- 序列<`P1`, `P2`, `P3`,...,`Pn`>是安全的：针对每个`Pi`，`Pi`要求的资源能够由当前可用的资源+所有的`Pj`持有的资源来满足，其中j<i

  如果`Pi`资源的需求不是立即可用，那么`Pi`可以等到所有`Pj`完成

  当`Pi`完成后，`Pi+1`可以得到所需要的资源，执行，返回所分配的资源，并终止

  用同样的方法，`Pi+2`，`Pi+3`和`Pn`能获得所需的资源



- 如果系统处于安全状态===>无死锁
- 如果系统处于不安全状态===>可能死锁
- **避免死锁**：确保系统永远不会进入不安全状态

{{< image classes="fancybox center fig-100" src="/os/os11_7.png" thumbnail="/os/os11_7.png" title="">}}

如下图11-4，死锁避免机制检验下一时刻的状态是否安全，然后根据情况将`edge`转换（图中实现虚线的转换，即尽管你有请求意图，但是可能并不允许占用）。

{{< image classes="fancybox center fig-100" src="/os/os11_8.png" thumbnail="/os/os11_8.png" title="图11-4 死锁避免机制检验图">}}

> **银行家算法**
>
> 银行家算法（Banker's Algorithm）是一个**死锁避免**的著名算法，是由爱兹格·迪杰斯特拉在1965年为`T.H.E`系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。
>
> 
>
> **背景**
>
> 在银行系统中，客户完成项目需要申请贷款的数量是有限的，每个客户在第一次申请贷款时声明完成该项目所需的最大资金量，在满足所有贷款要求并完成项目时，客户应及时归还。
>
> 银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。
>
> 在这样的描述中，银行就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。
>
> 
>
> **银行家算法前提条件**
>
> - 多个实例
> - 每个进程都必须能最大限度的利用资源
> - 当一个进程请求一个资源，就不得不等待
> - 当一个进程获得所有的资源就必须在一段有限的时间释放它们
>
> 基于上述前提条件，银行家算法通过尝试寻找允许每个进程获得的最大资源并结束（把资源返回给系统）的进程请求的一个理想执行时序，来决定一个状态是否是安全的；不存在这满足要求的执行时序的状态都是不安全的。
>
> 
>
> **银行家算法数据结构**
>
> n= 进程数量，m=资源类型数量
>
> - **Max（总需求量）**
>
>   `nxm`矩阵，如果Max[i,j] = k,表示进程`Pi`最多请求资源类型`Rj`的k个实例。
>
> - **Available（剩余空闲量）**
>
>   长度为m的向量。如果Available[j] = k，有空格类型`Rj`的资源实例可用。
>
> - **Allocation（已分配量）**
>
>   `nxm`矩阵，如果Allocation[i,j] = k,则`Pi`当前分配了k个`Rj`的实例
>
> - **Need（未来需要量）**
>
>   `nxm`矩阵，如果Need[i,j] = k，则`Pi`可能需要至少k个`Rj`实例完成任务
>
> ```c
> Need[i, j] = Max[i ,j] - Allocation[i ,j]
> ```
>
> 
>
> **安全状态的银行家算法**
>
> 1. `Work`和`Finish`分别是长度`m`和`n`的向量
>
>    初始化
>
>    ```c
>    Work = Avaliable;			//当前资源剩余空闲量
>    Finish[i] = false; for 1-n	//线程i没结束
>    ```
>
> 2. 找这样的`i`
>
>    ```c
>    (a)Finish[i] = false;
>    (b)Need <= Work
>    ```
>
>    没找到这样的`i`，转4
>
> 3. ```c
>    Work = Work + Allocation;	//进程i的资源需求量小于当前剩余空闲资源量，所以配置给它在回收
>    Finish[i] = true;
>    ```
>
>    转2
>
> 4. ```c
>    if Finish[i] == true; for all i //所有进程的Finish为true，表明系统处于安全状态
>    Then the system is in a safe state.
>    ```
>
> 
>
> 举例说明
>
> `Max`为所有进程需要资源矩阵，`Need`为所有进程当前需要资源矩阵。首先查找是否存在一个进程向量是小于等于可获取资源向量`V`的向量。
>
> {{< image classes="fancybox center fig-100" src="/os/os11_9.png" thumbnail="/os/os11_9.png" title="">}}
>
> 很明显可以找到这个`P2`的资源，然后等待`P2`进程结束，并释放对应的`P2`的资源。释放完成后，可可获取资源向量`V`就会增加到{6， 2,  3}。
>
> {{< image classes="fancybox center fig-100" src="/os/os11_10.png" thumbnail="/os/os11_10.png" title="">}}
>
> 这个时候查找是否存在一个进程向量是小于等于可获取资源向量`V`的向量，很明显`P1`进程。然后等待`P1`进程结束，并释放对应的`P1`的资源。释放完成后，可可获取资源向量`V`就会增加到{7， 2,  3}。
>
> {{< image classes="fancybox center fig-100" src="/os/os11_11.png" thumbnail="/os/os11_11.png" title="">}}
>
> 同理，可以找到`P3`进程。然后等待`P3`进程结束，并释放对应的`P3`的资源。释放完成后，可可获取资源向量`V`就会增加到{9， 3,  4}。
>
> {{< image classes="fancybox center fig-100" src="/os/os11_12.png" thumbnail="/os/os11_12.png" title="">}}
>
> 因此，这个得到的安全序列是`P2`-->`P1`-->`P3`-->`P4`。
>
> 
>
> 但是，如果如果在当前某一时刻查找是否存在一个进程向量是小于等于可获取资源向量`V`的向量，找不到，那么就是**不安全**的状态。
>
> {{< image classes="fancybox center fig-100" src="/os/os11_13.png" thumbnail="/os/os11_13.png" title="">}}





### 11.4.3死锁检测

- 允许系统进入死锁状态
- 死锁检测算法



把资源分配图简化为等待图

{{< image classes="fancybox center fig-100" src="/os/os11_14.png" thumbnail="/os/os11_14.png" title="">}}



资源类型的数据结构

- **Available**

  长度为M的向量表示每种类型可用资源的数量

- **Allocation**

  一个`nxm`矩阵定义了当前分配给各个进程每种类型资源的数量。如果Allocation[i, j] = k，进程`Pi`拥有资源`Rj`的k个实例

- **Request**

  一个`nxm`矩阵表示各进程的当前请求。如果Request[i, j] = k，表示进程`Pi`请求k个资源`Rj`的实例



**死锁检测算法**

虽然说死锁是可以被检测出来，但是检测的花销比较大，所以一般操作系统不回去检查

{{< image classes="fancybox center fig-100" src="/os/os11_15.png" thumbnail="/os/os11_15.png" title="">}}



举例说明

可以看到下图11-5所示，资源ABC，分别资源类型为7,2,6种。可以看到在当前时候由于`P0`不需要额外的资源，等待`P0`结束，资源B的一个类型实例可以释放出来，同理`P2`也是不需要额外资源，等待`P2`资源释放，资源向量为{3, 1, 3}。那么剩余的进程中找是否存在申请资源小于可获得的资源，显然存在。那么以此类推可以得到序列`P0`-->`P2`-->`P1`-->`P3`-->`P4`

{{< image classes="fancybox center fig-100" src="/os/os11_16.png" thumbnail="/os/os11_16.png" title="图11-5 死锁检测算法图">}}



与刚才的例子相似，发现没有一个进程它所需要的资源能够得到满足，这种情况下可能会产生**死锁**。

{{< image classes="fancybox center fig-100" src="/os/os11_17.png" thumbnail="/os/os11_17.png" title="">}}



**检测算法使用**

- **何时、使用什么样的频率来检测依赖于**

  死锁多久可能会发生

  多少金城需要被回滚

- 如果检测算法多次被调用，有可能是资源图有多个循环，所以我们无法分辨出多个可能死锁进程中的**哪些造成死锁**。



### 11.4.4死锁恢复

- 终止所有的死锁进程

- 在一个时间内终止一个进程直到死锁消除

- 终止进程的顺序应该是

  进程的优先级

  进程运行了多久以及需要多少时间才能完成

  进程占用的资源

  进程完成需要的资源

  多少进程需要被终止

  进程是交互还是批处理



- 选择一个受害者-最小的成本
- 回滚-返回到一些安全状态，重启进程到安全状态
- 饥饿- 同以进程可能一直被选作受害者，包括回滚的数量
